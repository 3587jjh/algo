struct Info {/**write**/};
struct SegTree {
	int n;
	vector<Info> tree;
	
	SegTree():n(0){}
	SegTree(const VL& A) { // 1-based
		assert(!A.empty());
		n = A.size()-1; tree.resize(4*A.size());
		init(1, 1, n, A);
	}
	Info init(int node, int nl, int nr, const VL& A) {
		if (nl == nr) return tree[node] = /**write**/
		int nm = (nl+nr)/2;
		return tree[node] = merge(init(node*2, nl, nm, A),
			init(node*2+1, nm+1, nr, A));
	}
	Info query(int l, int r, int node, int nl, int nr) {
		if (r < nl || nr < l) return /**write**/
		if (l <= nl && nr <= r) return tree[node];
		int nm = (nl+nr)/2;
		return merge(query(l, r, node*2, nl, nm),
			query(l, r, node*2+1, nm+1, nr));
	}
	Info update(int l, int r, Info val, int node, int nl, int nr) {
		if (r < nl || nr < l) return tree[node];
		if (l <= nl && nr <= r) return tree[node] = val;
		int nm = (nl+nr)/2;
		return tree[node] = merge(update(l, r, val, node*2, nl, nm),
			update(l, r, val, node*2+1, nm+1, nr));
	}
	/******user interface******/
	// fill "/**write**/" before use
	Info merge(Info a, Info b) {/**write**/}
	Info query(int l, int r) {
		return query(l, r, 1, 1, n);
	}
	void update(int l, int r, Info val) {
		update(l, r, val, 1, 1, n);
	}
};
