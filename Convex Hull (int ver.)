struct VT {
	LL x, y;
	VT(LL _x=0, LL _y=0):x(_x),y(_y){}
	bool operator <(const VT& rhs) const {
		return x != rhs.x ? x < rhs.x : y < rhs.y;
	}
	VT operator -(const VT& rhs) const {
		return VT(x-rhs.x, y-rhs.y);
	}
	LL norm() const {return x*x + y*y;} // return size^2
	LL cross(const VT& rhs) const {
		return x*rhs.y - y*rhs.x;
	}
};
LL ccw(VT p, VT a, VT b) {
	return (a-p).cross(b-p);
}

struct Comparator {
	VT pivot;
	Comparator(VT _pivot):pivot(_pivot){}
	bool operator ()(VT a, VT b) {
		LL det = ccw(pivot, a, b);
		if (det != 0) return det > 0;
		return (a-pivot).norm() < (b-pivot).norm();
	}
};
vector<VT> grahamScan(vector<VT>& p) {
	VT pivot = *min_element(p.begin(), p.end());
	sort(p.begin(), p.end(), Comparator(pivot));
    vector<VT> ret;
	
	for (int i = 0; i < p.size(); ++i) {
		while (ret.size() >= 2) {
			VT a = ret[ret.size()-2];
			VT b = ret[ret.size()-1];
			LL det = ccw(a, b, p[i]);
			if (det > 0) break;
			ret.pop_back();
		}
		ret.push_back(p[i]);
	}
	return ret;
}
