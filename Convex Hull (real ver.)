const double PI = 2*acos(0.0);
bool equal(double a, double b) {
	double diff = fabs(a - b);
	if (diff < 1e-10) return true;
	return diff < 1e-8 * max(fabs(a), fabs(b));
}
struct VT {
	double x, y;
	VT(double _x=0, double _y=0) : x(_x),y(_y){}
	bool operator ==(const VT& rhs) const {
		return equal(x, rhs.x) && equal(y, rhs.y);
	}
	bool operator <(const VT& rhs) const {
		if (*this == rhs) return false;
		return !equal(x, rhs.x) ? x < rhs.x : y < rhs.y;
	}
	bool operator <=(const VT& rhs) const {
		return *this == rhs || *this < rhs;
	}
	VT operator +(const VT& rhs) const {
		return VT(x + rhs.x, y + rhs.y);
	}
	VT operator -(const VT& rhs) const {
		return VT(x - rhs.x, y - rhs.y);
	}
	VT operator *(double rhs) const {
		return VT(x * rhs, y * rhs);
	}
	double norm() const { return hypot(x, y); }
	VT normalize() const {
		double p = norm();
		if (equal(p, 0.0)) return *this;
		return VT(x / p, y / p);
	}
	double dot(const VT& rhs) const {
		return x * rhs.x + y * rhs.y;
	}
	double cross(const VT& rhs) const {
		return x * rhs.y - y * rhs.x;
	}
	VT project(const VT& rhs) const {
		VT r = rhs.normalize();
		return r * r.dot(*this);
	}
};
double ccw(VT a, VT b, VT c) {
    return (b - a).cross(c - a);
}

struct Comparator {
	VT pivot;
	Comparator(VT _pivot):pivot(_pivot){}
	bool operator ()(VT a, VT b) {
		double det = ccw(pivot, a, b);
		if (!equal(det, 0)) return det > 0;
		return (a-pivot).norm() < (b-pivot).norm();
	}
};
vector<VT> grahamScan(vector<VT>& p) {
	VT pivot = *min_element(p.begin(), p.end());
	sort(p.begin(), p.end(), Comparator(pivot));
    vector<VT> ret;
	
	for (int i = 0; i < p.size(); ++i) {
		while (ret.size() >= 2) {
			VT a = ret[ret.size()-2];
			VT b = ret[ret.size()-1];
			double det = ccw(a, b, p[i]);
			if (!equal(det, 0) && det > 0) break;
			ret.pop_back();
		}
		ret.push_back(p[i]);
	}
	return ret;
}
